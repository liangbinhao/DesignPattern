
## 什么是单例

单例指的是在程序运行期间某个类只存在一个全局的实例，例如线程池、工具类等

## 如何实现单例

实现单例需要满足三个条件
1. 类的构造方法需要设置为私有，可以保证不能从外部new一个对象
2. 在该类中创建一个对象，因为无法从外部new对象，因此需要从内部创建一个对象
3. 提供一个让外部获取该对象的方法

## 单例模式的写法

单例的写法可分为五种
- 饿汉式
- 懒汉式
- 双重判定锁
- 静态内部类
- 枚举

### 饿汉式

```java
public class Singleton{
	private static Singleton instance=new Singleton();
	private Singleton(){}
	public Singleton getInstance(){
		return instance;
	}
}
```

该方式会在程序初始化的时候创建单例，缺点是可能会占用不必要的系统资源

### 懒汉式

```java
public class Singleton{
	private static Singleton instance;
	private Singleton(){}
	public static synchronized getInstance(){
		if(instance==null){
			instance=new instance();
		}
		return instance;
	}
}
```

该方式会在第一次使用时创建单例，即惰性初始化，为了保证并发安全，使用`synchronized`修饰该方法，确保对象被创建一次，但效率不高
由于方法使用了`synchronized`修饰，所以不需要使用`volatile`关键字修饰变量，因为当线程退出同步块时，会将工作内存中对instance的修改刷新到主内存，这是有`synchronized`的happens-before原则来保证的，前一个线程在`synchronized`块内的写操作，对后续进入该同步块的线程是可见的

### 双重检查锁

```java
public class Singleton{
	private static volatile Singleton instance;
	private Singleton(){}
	public static Singleton getInstance(){
		if(instance==null){
			synchronized(Singleton.class){
				if(instance==null){
					instance=new Singleton();
				}
			}
		}
		return instance;
	}
}
```

为什么需要`volatile`修饰
在Java中，`new Singleton()`这一行代码实际上包含三个步骤：
- 分配内存空间
- 初始化对象
- 将引用指向分配的内存地址
  但在某些JVM实现中，步骤2和步骤3可能发生重排序，即先执行第3步，再执行第2步

考虑没有`volatile`的双重检查锁
- 线程A进入`synchronized`块，执行`new Singleton()`
- 由于指令重排序，JVM先把`instance`指向一块已分配但尚未初始化的内存
- 此时`instance!=null`
- 线程B调用`getInstance()`，第一次检查发现`instance!=null`，直接返回一个未完全初始化的对象
- 线程B使用这个“半成品”对象，可能导致`NullPointerException`或其他未定义行为

对`volatile`变量的写操作具有happens-before，可以避免该问题

为什么这里的`synchronized`不能保证happens-before原则
因为第一次的instance读取不在同步代码块中，无法建立起happens-before关系，也即该实现中对于第5行的instance读取是不受保护的，可能线程A创建对象时第3步和第2步进行了重排，instance先指向了一个未初始化的内存，此时监视器锁还未释放，但如果此时B执行到了第5行可能获取到不为null的instance，因此返回的可能是一个为完全初始化的对象

### 静态内部类

```java
public class Singleton{
	private Singleton(){}
	private static class SingletonHolder{
		private static Single instance = new Single();
	}
	
	public static Singleton getInstance(){
		return SingletonHolder.instance;
	}
}
```

利用类加载机制保证线程安全和懒加载，因为`Singleton`类被加载时，不会立即加载`Holder`内部类，只有当首次访问`Holder.instance`时，JVM才会去加载并初始化`Holder`类，而类的初始化过程是线程安全的，这是由JVM来保证的

### 枚举

```java
public enum Singleton{
	instance;
	
	// 可以添加数据和构造函数
	private String data;
	private Singleton(){
		this.data="单例数据";
	}
	
	public void setDate(String data){
		this.data=data;
	}
	
	public String getDate(){
		return this.data;
	}
}
```

在所有的单例实现中，只有通过枚举实现的可以防止通过反射重新新的对象，主要原因为
1. JVM层面有特殊处理
    - 编辑器限制：enum类型在编译时会被特殊处理
    - 构造函数限制：枚举的构造函数必须是private的，且不能通过反射调用来创建新实例
2. 反射机制的安全检查
```java
Constructor<?> constructor = SingletonEnum.class.getDeclaredConstructor();  
constructor.setAccessible(true);  
// 下面这行代码会抛出异常
Enum<?> instance = (Enum<?>) constructor.newInstance();
```

## 反射攻击

对于以上5中创建单例的方法，只有枚举方式可以防止反射攻击，其他四种方式都可以通过反射的方式获取类的构造器，并使用`setAccessable(true)`访问类的构造函数创建新的对象来破坏单例